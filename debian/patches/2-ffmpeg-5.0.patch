diff --git a/plugins/core/Standard/qAnimation/extern/QTFFmpegWrapper/QVideoEncoder.cpp b/plugins/core/Standard/qAnimation/extern/QTFFmpegWrapper/QVideoEncoder.cpp
index 83dae31b..13d58b8d 100644
--- a/plugins/core/Standard/qAnimation/extern/QTFFmpegWrapper/QVideoEncoder.cpp
+++ b/plugins/core/Standard/qAnimation/extern/QTFFmpegWrapper/QVideoEncoder.cpp
@@ -106,30 +106,20 @@ bool QVideoEncoder::GetSupportedOutputFormats(std::vector<OutputFormat>& formats
 	try
 	{
 		// list of all output formats
-		AVOutputFormat* prev = nullptr;
-		while (true)
+		const AVOutputFormat* format = NULL;
+		void* iter = NULL;
+		while ((format = av_muxer_iterate(&iter)))
 		{
-			AVOutputFormat* format = av_oformat_next(prev);
-			if (format)
+			//potentially skip the output formats without any extension (= test formats mostly)
+			if (	format->video_codec != AV_CODEC_ID_NONE
+				&&	(!ignoreIfNoFileExtension || (format->extensions && format->extensions[0] != 0))
+				)
 			{
-				//potentially skip the output formats without any extension (= test formats mostly)
-				if (	format->video_codec != AV_CODEC_ID_NONE
-					&&	(!ignoreIfNoFileExtension || (format->extensions && format->extensions[0] != 0))
-					)
-				{
-					OutputFormat f;
-					{
-						f.shortName = format->name;
-						f.longName = format->long_name;
-						f.extensions = format->extensions;
-					}
-					formats.push_back(f);
-				}
-				prev = format;
-			}
-			else
-			{
-				break;
+				OutputFormat f;
+				f.shortName = format->name;
+				f.longName = format->long_name;
+				f.extensions = format->extensions;
+				formats.push_back(f);
 			}
 		}
 	}
@@ -156,7 +146,7 @@ bool QVideoEncoder::open(QString formatShortName, QStringList& errors)
 		return false;
 	}
 
-	AVOutputFormat* outputFormat = NULL;
+	const AVOutputFormat* outputFormat = NULL;
 	if (!formatShortName.isEmpty())
 	{
 		outputFormat = av_guess_format(qPrintable(formatShortName), NULL, NULL);
@@ -192,7 +182,7 @@ bool QVideoEncoder::open(QString formatShortName, QStringList& errors)
 	AVCodecID codec_id = m_ff->formatContext->oformat->video_codec;
 	//codec_id = AV_CODEC_ID_MPEG1VIDEO;
 	//codec_id = AV_CODEC_ID_H264;
-	AVCodec *pCodec = avcodec_find_encoder(codec_id);
+	const AVCodec *pCodec = avcodec_find_encoder(codec_id);
 	if (!pCodec)
 	{
 		errors << "Could not load the codec";
@@ -242,7 +232,9 @@ bool QVideoEncoder::open(QString formatShortName, QStringList& errors)
 		return false;
 	}
 	m_ff->videoStream->id = m_ff->formatContext->nb_streams-1;
-	m_ff->videoStream->codec = m_ff->codecContext;
+	m_ff->videoStream->codecpar = avcodec_parameters_alloc();
+	avcodec_parameters_from_context(m_ff->videoStream->codecpar,
+	                                m_ff->codecContext);
 	m_ff->videoStream->time_base.num = 1;
 	m_ff->videoStream->time_base.den = m_fps;
 
@@ -316,11 +308,9 @@ bool QVideoEncoder::close()
 		memset( &pkt, 0, sizeof( AVPacket ) );		
 		av_init_packet(&pkt);
 
-		int got_packet = 0;
-		int ret = avcodec_encode_video2(m_ff->codecContext, &pkt, 0, &got_packet);
-		if (ret < 0 || !got_packet)
+		while (avcodec_receive_packet(m_ff->codecContext, &pkt) > 0)
 		{
-			break;
+			write_frame(m_ff, &pkt);
 		}
 
 		write_frame(m_ff, &pkt);
@@ -331,16 +321,18 @@ bool QVideoEncoder::close()
 	av_write_trailer(m_ff->formatContext);
 
 	// close the codec
-	avcodec_close(m_ff->videoStream->codec);
+	avcodec_free_context(&m_ff->codecContext);
 
 	// free the streams and other data
 	freeFrame();
 	for(unsigned i = 0; i < m_ff->formatContext->nb_streams; i++)
 	{
-		av_freep(&m_ff->formatContext->streams[i]->codec);
+		avcodec_parameters_free(&m_ff->formatContext->streams[i]->codecpar);
 		av_freep(&m_ff->formatContext->streams[i]);
 	}
 
+	avcodec_parameters_free(&m_ff->videoStream->codecpar);
+
 	// close the file
 	avio_close(m_ff->formatContext->pb);
 
@@ -372,39 +364,49 @@ bool QVideoEncoder::encodeImage(const QImage &image, int frameIndex, QString* er
 	av_init_packet(&pkt);
 
 	// encode the image
-	int got_packet = 0;
-	{
-		//compute correct timestamp based on the input frame index
-		//int timestamp = ((m_ff->codecContext->time_base.num * 90000) / m_ff->codecContext->time_base.den) * frameIndex;
-		m_ff->frame->pts = frameIndex/*timestamp*/;
+	char errorStr[AV_ERROR_MAX_STRING_SIZE] = {0};
+	//compute correct timestamp based on the input frame index
+	//int timestamp = ((m_ff->codecContext->time_base.num * 90000) / m_ff->codecContext->time_base.den) * frameIndex;
+	m_ff->frame->pts = frameIndex/*timestamp*/;
+
+	int retcode = true;
+	int ret = avcodec_send_frame(m_ff->codecContext, m_ff->frame);
+	if (ret < 0) {
+		av_make_error_string(errorStr, AV_ERROR_MAX_STRING_SIZE, ret);
+		if (errorString)
+			*errorString = QString("Error sending a frame for encoding: %1").arg(errorStr);
+		av_packet_unref(&pkt);
+		return false;
+	}
 
-		int ret = avcodec_encode_video2(m_ff->codecContext, &pkt, m_ff->frame, &got_packet);
-		if (ret < 0)
+	while (ret >= 0)
+	{
+		ret = avcodec_receive_packet(m_ff->codecContext, &pkt);
+		if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
+			break;
+		else if (ret < 0)
 		{
-			char errorStr[AV_ERROR_MAX_STRING_SIZE] = {0};
-			av_make_error_string(errorStr, AV_ERROR_MAX_STRING_SIZE, ret);
-			if (errorString)
-				*errorString = QString("Error encoding video frame: %1").arg(errorStr);
-			return false;
+ 			av_make_error_string(errorStr, AV_ERROR_MAX_STRING_SIZE, ret);
+ 			if (errorString)
+ 				*errorString = QString("Error encoding video frame: %1").arg(errorStr);
+			retcode = false;
+			break;
 		}
-	}
 
-	if (got_packet)
-	{
-		int ret = write_frame(m_ff, &pkt);
+	    ret = write_frame(m_ff, &pkt);
 		if (ret < 0)
 		{
-			char errorStr[AV_ERROR_MAX_STRING_SIZE] = {0};
 			av_make_error_string(errorStr, AV_ERROR_MAX_STRING_SIZE, ret);
 			if (errorString)
 				*errorString = QString("Error while writing video frame: %1").arg(errorStr);
-			return false;
+			retcode = false;
+			break;
 		}
 	}
 
 	av_packet_unref(&pkt);
 	
-	return true;
+	return retcode;
 }
 
 bool QVideoEncoder::convertImage_sws(const QImage &image, QString* errorString/*=nullptr*/)
